name: Deploy to Kubernetes

on:
  workflow_run:
    workflows: ["Build Docker Image"]
    types:
      - completed
    branches: [main]
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Docker image tag to deploy (e.g., main-abc1234)'
        required: false
        default: 'latest'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  K8S_NAMESPACE: jovies

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure kubectl with Lightsail
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

          # Verify connection
          kubectl cluster-info
          kubectl get nodes

      - name: Determine image tag
        id: image
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TAG="${{ github.event.inputs.image_tag }}"
          else
            # Use the commit SHA from the workflow_run event
            TAG="main-$(echo ${{ github.sha }} | cut -c1-7)"
          fi

          FULL_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "full_image=${FULL_IMAGE}" >> $GITHUB_OUTPUT
          echo "ğŸ³ Deploying image: ${FULL_IMAGE}"

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ env.K8S_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to Kubernetes
        run: |
          echo "ğŸš€ Applying Kubernetes manifests..."
          kubectl apply -f deploy/k8s/ -n ${{ env.K8S_NAMESPACE }}

          echo "ğŸ”„ Updating deployment image..."
          kubectl set image deployment/jovies-app \
            jovies-app=${{ steps.image.outputs.full_image }} \
            -n ${{ env.K8S_NAMESPACE }}

          kubectl patch deployment jovies-app \
            -n ${{ env.K8S_NAMESPACE }} \
            --type='json' \
            -p='[{"op":"replace","path":"/spec/template/spec/containers/0/imagePullPolicy","value":"IfNotPresent"}]'

      - name: Wait for rollout to complete
        run: |
          echo "â³ Waiting for deployment rollout..."
          kubectl rollout status deployment/jovies-app \
            -n ${{ env.K8S_NAMESPACE }} \
            --timeout=5m

      - name: Verify deployment
        run: |
          echo "ğŸ“Š Deployment status:"
          kubectl get deployments -n ${{ env.K8S_NAMESPACE }}

          echo ""
          echo "ğŸ” Pod status:"
          kubectl get pods -n ${{ env.K8S_NAMESPACE }}

          echo ""
          echo "ğŸŒ Service status:"
          kubectl get services -n ${{ env.K8S_NAMESPACE }}

      - name: Get deployment info
        run: |
          echo "âœ… Deployment completed!"
          echo ""
          echo "ğŸ“¦ Deployed image: ${{ steps.image.outputs.full_image }}"
          echo "ğŸ·ï¸  Namespace: ${{ env.K8S_NAMESPACE }}"
          echo ""
          echo "ğŸ”— Useful commands:"
          echo "  - View logs: kubectl logs -n ${{ env.K8S_NAMESPACE }} -l app=jovies-app -f"
          echo "  - Port forward: kubectl port-forward -n ${{ env.K8S_NAMESPACE }} deploy/jovies-app 3000:3000"
          echo "  - Rollback: kubectl rollout undo deployment/jovies-app -n ${{ env.K8S_NAMESPACE }}"

      - name: Deployment failure notification
        if: failure()
        run: |
          echo "âŒ Deployment failed!"
          echo "Check logs with: kubectl logs -n ${{ env.K8S_NAMESPACE }} -l app=jovies-app"
          exit 1
